# 본문의 글은 인프런 앨런 Swift문법 마스터 스쿨(온라인) 부트캠프의 강의 영상을 본후 공부한 내용을 정리하여 기록한것입니다.
https://inf.run/YyoR

일단 앞으로의 내용을 이해하기 위해서는 혹은 이 전의 내용또한 쉽게 이해하기 위해서는   
클래스와 구조체의 그리고 저장속성과 메서드의 메모리 구조의 대해 자세하게 알 필요 가 있다.  

# 가장 기본적인 메모리 구조

예를 들어 3 + 4 라는 아주 간단한 프로그램이 있다고 해보자   
코드 부분에는 코드가 올라간다   
3을 임의의 공간에 저장    
4를 임의의 공간에 저장   
3 과 4를 더함   
결과를 출력함    

이런식으로 코드부분에 코드가  올라가면    데이터 힙 스택 부분에는 이렇게 올라가게 된다.
   
주소 3   
주소 4   
주소 7   
   
이런식으로 말이다.   
   
기본적으로 코드에는 명령어가 올라가고    
데이터에는 전역변수/ 타입변수 등 공통으로 공유하기 위한 데이터가 올라간다 이건 앱이 실행되는동안 불변이다.    
힙에는 동적할당(일반적으로 오랫동안 긴시간동안 저장) 되는 데이터 크기가 크고 관리할필요가 있는 그런 데이터가 올라간다.   
스택에는 함수 실행을 위한 임시적인 공간 즉 크기가 작고 빠르게 사용하기위한 데이터가 올라간다.   

이게 가장 기본적인 메모리의 구조이다.   
   
# 함수의 메모리 구조
함수는 어떤 명령어의 묶음을 이름을정해 만든것으로 그 명령어의 묶음을 사용하고 싶을때마다 꺼내서 쓸수있도록 하는 녀석이다.    
위에 코드를 함수로 만들었다 해보자    
```swift
func addTwoNumbers(a: Int, b: Int) -> Int {
    var c = a + b
    return c
}
```
그럼 코드칸에는 이렇게 들어 갈 것이다.   
  
addTwoNumbers   
임시공간을 만든다.   
a라는 상수에 Int(값)를 저장한다.    
b라는 상수에 Int(값)를 저장한다.   
 c 변수 공간을 만든다.   
a + b를 더해서 임시값을 가진다.    
임시값을 c에 저장 한다.   
c를 리턴(반환)한다.    
MAIN:    
num1 이라는 변수에 5를 저장한다.    
num2 이라는 변수에 3를 저장한다.    
num3 변수 공간을 만든다.    
addTwoNumbers 함수를 실행   
num3애 저장    
print 실행    
   
     
      
메인함수는 앱을키자마자 실행하는 어떤 시발점인 함수이다.   
메인함수가 작동하면 스택부분에서 메인함수 공간을 만들고 num1에 5를 저장하고 num2에 3을저장하고 num3라는 변수를 Int타입으로 만들것이다.   
그뒤에 스택부분에서 addTwoNumbers 라는 함수 공간이 또 만들어진다.   
그리고 차례차례 함수의 코드를 수행한다. 일단 복귀주소를 가지고.. 임시공간을 만들고.. a라는 상수에 값을 저장하고 등등.....    
그렇게 마지막으로 c를 리턴하게 되면 다시 복귀 주소를 통해 메인함수로 돌아오게된다.   
그럼 num3라는 Int타입의 공간에 리턴된 c의값이 저장되게되고   
똑같은 매커니즘으로 print함수도 실행하고 나면 메인함수의 공간 역시 사라진다    
요약하자면 함수는 어떤 명령어의 묶음이고 이 명령어의 묶음이 필요할때마다 함수의 이름을 써주면    
그 함수의 코드줄로 찾아가고 그 함수를 스택에 쌓으면서 함수를 실행하게된다.    
1000번째의 코드에 함수를 실행하라는 코드가 써있따면  500번째 함수의 주소로 찾아가서 그 함수를 실행시키고 명렁어를 스택에서 쌓아가면서 실행하는것이다.    
그래고 그 명령어들이 모두 실행되면 복귀주소를 통해 복귀하고 함수의 모든 명령어가 실행되면 해당 스택프레임은 사라지게 된다.    
이게 함수의 메모리 구조이다.    

# 클래스와 구조체의 메모리 구조
클래스는 클래스 자체는 데이터에 저장이되고 클래스의 인스턴스들은 힙이 저장되어 데이터에있는 클래스의 주소를 가리킨다.   
그리고 그런 변수들은 스택에 메인함수에 또 저장되고 그 스택에있는 데이터는 힙에있는 실제 인스턴스의 데이터를 가리킨다.  
쉽게얘기해 실제 값은 힙에 있고 스택에서는 주소를 찾아가서 쓰는것이다.   
       
구조체는 구조체 자체는 데이터에 저장이되지만 클래스처럼 힙에저장되고 메임하수에서 힙에 주소를 가리키고 그런것이아니라 데이터 자체가 복사되어서 스택에 메인함수에 저장되어 데이터에 구조체를 가리킨다.   
쉽게 얘기해 실제 값은 을 스택에 복사해서 쓰는것이다.   




# 클래스 저장속성의 메모리구조

```swift
class Dog {
    var name = "강아지"
    var weight = 0
}

var bori = Dog()
bori.name = "보리"
bori.weight = 10
```
클래스의 경우   
여기서 Dog라는 클래스는 데이터에 저장이된다.    
bori라는 변수에 name이나 weight는 힙에 저장이된다.    
스택에서는 bori 변수의 값의 주소만있다 그리고 이 주소는 힙에있는 bori를 가리킨다.      
역순으로 이해하면 편하다   
스택에서 bori라는 변수의 메모리 주소가 담김 -> 이 주소는 힙의 영역에 실제 bori 변수를 가리킴  -> 이 힙에 있는 실제 bori변수는 결국 데이터에있는 클래스 Dog를 가리킴
    

# 구조체 저장속성의 메모리구조

```swift
struct Dog {
    var name = "강아지"
    var weight = 0
}

var bori = Dog()
bori.name = "보리"
bori.weight = 10
```

구조체의 경우 클래스와 다르게 헵이 저장되고 주소만 스택에있는게 아니라
bori라는 변수 자체가 스택에 저장이된다.   
이건 역순으로 생각할것도 없이 스택에서 bori라는 변수가 담김 -> 이 스택에 있는 bori변수는 데이터에있는 스트럭트 Dog를 가리킴
    

# 클래스 메서드의 메모리구조

```swift
class Dog {
    var name = "강아지"
    var weight = 0
    
    func sit () {
        print("앉았습니다")
    }
}

var bori = Dog()
bori.sit()
```

함수는 결국 코드영역에서 어떤 명령어의 묶음이다 그래서 코드영역에 어떤 명령어 묶으로 있을것이다 이걸 꼭 이해하자,   
    
    
bori.sit()을 실행 시키면 힙에 있는 bori 변수를 찾아간다.   
bori는 클래스 Dog 를 가리키고 있으니 찾아간다.       
그리고 클래스 Dog안에 있는 sit() 함수를 찾아간다.     
그러면 sit()함수 안에 그 sit() 함수가 실제 있는 주소가 또 들어있을것이다 그 주소를 찾아가면.     
코드영역에있는 예를들어 코드영역 100번째 줄에있는 명령어 묶음안에 명령어(print)를 하나하나 스택프레임에 만들고 동작할것이다.   


# 구조체 메서드의 메모리구조

```swift
struct Dog {
    var name = "강아지"
    var weight = 0
    
    func sit () {
        print("앉았습니다")
    }
}

var bori = Dog()
bori.sit()
```

bori.sit()을 실행 시키면 스택에있는 bori변수를 찾아간다.    
bori변수는 스트럭트 Dog를 가리키고 있으니 찾아간다.   
스트럭트 Dog안에있는 sit() 함수를 찾아간다.   
sit()함수가 실제 있는 주소가 있을것이다 그 주소를 찾아간다.   
코드영역에 101번째 줄에있는 그 명령어 묶음에서 명령어를 꺼내 스택프레임을 만들고 동작한다.    
구조체를 이렇게 설명했지만 사실은 더 간단한게 동작한다.   
코드에서 bori.sit함수를 만나면 바로 코드에서 주소를 찾아서 101번째 줄에있는 명령어 묶음을 찾아간다 함수의 메모리 구조처럼 말이다.   
그래서 클래스보다 아주 빠르게 실행된다.   
   
      
        
         
           

