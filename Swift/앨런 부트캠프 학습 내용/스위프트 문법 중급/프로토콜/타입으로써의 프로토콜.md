# 본문의 글은 인프런 앨런 Swift문법 마스터 스쿨(온라인) 부트캠프의 강의 영상을 본후 공부한 내용을 정리하여 기록한것입니다.
https://inf.run/YyoR


```swift
// 프로토콜은 ===> First Class Citizen(일급객체)이기 때문에, 타입(형식)으로 사용할 수 있음
// 1. 프로토콜은 변수에 할당할수 있고
// 2. 함수를 호출할때 파라미터로 프로토콜을 전달할수 있고
// 3. 함수에서 프로토콜을 반환할수 있다.


protocol 리모트 {
    func 온()
    func 오프()
}


class 티비: 리모트 {
    func 온() {
        print("티비켜기")
    }
    
    func 오프() {
        print("티피끄기")
    }
}

struct 셋톱박스: 리모트 {
    func 온() {
        print("셋톱박스 켜기")
    }
    
    func 오프() {
        print("셋톱박스 끄기")
    }
    
    func 넷플릭스() {
        print("넷플릭스 시청 하기")
    }
}

let 티비1 = 티비()

let 셋톱박스1 = 셋톱박스()


//프로토콜 타입 취급의 장점 ==================================

//장점 1.

let 전자제품: [리모트] = [티비1, 셋톱박스1] //프로토콜 형식으로 담겨 있음

for 아이템 in 전자제품 {
    아이템.오프()
}


//장점 2.

func 전자제품켜기(아이템: 리모트) {
    아이템.온()
}

전자제품켜기(아이템: 티비1)
전자제품켜기(아이템: 셋톱박스1)





//프로토콜 준수성 검사 ===============================

/*
 - is / as 연산자 사용가능

 - is 연산자 ===> 특정 타입이 프로토콜을 채택하고 있는지 확인 (참 또는 거짓) / 그 반대도 확인가능
 - as 연산자 ===> 타입 캐스팅 (특정 인스턴스를 프로토콜로 변환하거나, 프로토콜을 인스턴스 실제형식으로 캐스팅)
*/

// is 연산자를 통해 특정타입이 프로토콜을 채택하고 있는지 확인
티비() is 리모트
셋톱박스1 is 리모트

//프로토콜 타입으로 저장된 인스턴스가 더 구체적인 타입인지 확인 가능
전자제품[0] is 티비
전자제품[0] is 셋톱박스


//as 연산자 업캐스팅

let 박스 = 셋톱박스1 as 리모트
박스.오프()
박스.온()



//as 연산자 다운캐스팅
let 박스2 = 전자제품[1] as? 셋톱박스
박스2?.넷플릭스()
박스2?.오프()

(전자제품[1] as? 셋톱박스)?.넷플릭스() //이렇게도 가능

```