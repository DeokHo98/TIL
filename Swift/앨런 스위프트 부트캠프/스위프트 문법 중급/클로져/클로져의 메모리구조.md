# 본문의 글은 인프런 앨런 Swift문법 마스터 스쿨(온라인) 부트캠프의 강의 영상을 본후 공부한 내용을 정리하여 기록한것입니다.
https://inf.run/YyoR



```swift
/*
값형식의 메모리 저장위치는 stack에 저장이된다.
참조형식의 메모리 저장위츠는 힙에저장이되고 주소를 stack에 저장을 하는데
우리가 배운 클로저라는 녀석 또한 참조형식이다. 클래스랑 똑같은 메모리 구조를 가지고 있다는것

클로저 역시 함수이기때문에  cpu에대한 명령어 묶음을 코드영역에 있을것이다. 이 코드영역의 주소를 저장하는 공간을
 힙에 저장하고 있는것이다.

 */


//클로저의 캡처 현상 =======================

var stored = 0

let closure = { (num: Int) -> Int in
    stored += num
    return stored
}

closure(1)

closure(2)

closure(3)

closure(4)

closure(5)



//왜 이런결과가 나올까?
//실제로 클로저를 변수에 할당하거나 클로저를 호출하는 순간, 클로저는 자신이 참조하는 외부의 변수를
//캡처함 (지속적으로 외부변수를 사용해야하기 때문)

//쉽게 말해 외부션수를 사용하니까 클로저의 힙에 저장공간 안에 값을저장하거나 참조(주소)를 저장을 한다.







//일반적인 함수 =================
//함수내에서 함수를 실행하고 값을 리턴하는 일반적인 함수

func 계산(number: Int) -> Int {
    var sum = 0
    
    func square(num: Int) -> Int {
        sum += (num * num)
        return sum
    }
    
    let result = square(num: number)
    
    return result
}

계산(number: 10)
계산(number: 20)
계산(number: 30)


//변수를 캡쳐하는 함수 ================
//아래와 가은경우 충접함수로 이루어져 있고, 내부함수 외부에 계쏙 사용해야하는 값이 있기때문에 갭처현상이 발생한다.
// 힘수/클로저를 변수에 저장하느 시점에 캡쳐 --> 클로저도 참조타입

func 계산함수() -> ((Int) -> Int) { //리턴타입도 인풋도 int 아웃풋도 int인 함수를 리턴하는것
    var sum = 0
    
    func square(num: Int) -> Int {
        sum += (num * num)
        return sum
    }
    
    return square //함수를 리턴
}

//값을 리턴하는거랑 함수를 리턴하는건 무슨차이가 있는가....





//변수에 저장하는경우 힙에 유지된다.
var 계산함수2 = 계산함수() //내부에있느 함수를 꺼내서 변수에넣어준것이다 왜냐 함수를 리턴했기때문에.

계산함수2(10)
계산함수2(20)
계산함수2(30)

//어떤 함수가 외부 변수를 지속적으로 사용을할때 그 변수가 없어지면 에러가 나기때문에 그 변수를 지속적으로 사용하기위해서 하는것을
//캡쳐 라고 하는것, 결국 클로저는 계속해서 힙에 어떤 공간을 차지하고 있는것이다.






//변수에 저장하지 않는경우
//힙에 유지하지않음

//계산함수()(10)
//계산함수()(20)
//계산함수()(30)





//래퍼런스 타입
var dodofunc = 계산함수2
dodofunc(10)
```