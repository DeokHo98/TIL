# UnitTest

## UnitTest가 중요한 이유
버그 검출: UnitTest 코드는 작은 부분을 독립적으로 테스트하므로 개발자가 작성한 코드에 있는 버그를 검출하기 쉬움.             
또한 UnitTest를 통해 예상동작과 실제동작이 일치하는지 확인 가능.        
     
코드 변경의 안정성: 코드의 작은부분을 격리하여 테스트하고 항상 같은 결과만 나오면 테스트를 통과하기때문에.    
코드를 변경할때 다른 부분에 영향을 주지않고 더 안전하게 코드 변경이 가능함    
      
문서화와 예제 제공: UnitTest코드는 코드에 대한 사용 예제를 제공하고 그 자체로 문서화가 가능함.     
      
## TDD
    
TDD 3단계       
    
Red(실패): 실패하는 단위 테스트를 작성.   
이 단계에서는 구현되지 않은 기능을 테스트하는 단순하고 작은 테스트 케이스를 작성.     
    
Green(성공): 실패하는 테스트를 통과할수 있는 최소한의 코드를 작성.        
목표는 테스트를 통과시키는 가장 간단하고 효율적인 코드 찾기.    
    
Refactor(리팩토링): 코드를 리팩토링하고 개선.   
이는 코드의 구조를 개선하고 가독성을 높이는 등의 작업.    
이 작업을 통해 코드 품질 및 중복을 제거 하는것이 가능.     
역시나 계속해서 테스트를 통과하는지 확인해야함.   
    
     
테스트코드 역시 깨끗하게 작성해야함.    
지저분한 테스트코드 역시 변경하는 경우가 많기때문에 항상 깨꿋하게 작성.   
실제 코드를 작성한다 생각하고 작성해야함.    
    
     
깨끗한 테스트코드를 유지하는 방법.    
가장 중요한점은 바로 가독성이다.     
가독성은 실제코드보다 테스트코드에서 더 중요하다 왜냐하면 테스트코드는 최소한의 표현으로 많은것을 나타내야하기 때문.    
     
    
- 중복되거나 반복되는 코드 없애기 필요하면 함수를 만들어서 사용하기.    
- 테스트 함수 하나당 assert를 한개만 쓰기.    
- 테스트 함수 내부에 코드를 given when then 함수로 분리해서 사용하기.    
- 테스트 함수 하나당 테스트 하는 개념을 한개만 가져가기.   

## UnitTest의 FIRST 규칙
- Fast.    
빠르게 실행되어야한다.     
빠르게 실행되면 개발자가 코드 변경사항을 확인하고 디버깅하는데 시간절약 가능.   
느리다면 코드정리를 꺼리게 되고 자주 테스트하지 않음.    
      
- Independent.   
테스트코드는 서로 독립적으로 의존되지 않아야함.    
한 테스트의 실패가 다른 테스트에 영향을 미치면 안됨.    
    
- Repeatable.   
어떤 환경에서도 반복이 가능해야함.    
동일한 테스트를 여러번 실행해도 항상 같은 결과값을 얻어야함.  
예를들어 네트워크연결 환경이 아닐때에도 실행되도록 설계 해야함.    
     
- Self Validating.     
판단 결과라 통과 또는 실패로 명확하게 나와야함.   
로그를 읽고 해석하게 되면 주관적이게 됨.   
    
- Timely
실제 코드를 작성하기전에 작성해야함.   
실제 코드 작성후 테스트코드를 현하면 실제 코드를 테스트하기 어려워짐.        

