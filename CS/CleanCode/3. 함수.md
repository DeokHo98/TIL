# 함수
함수의 길이는 20줄도 긴것, 가능한 짧게 분리하는것이 가독성에 중요한 요소.   
함수 안의 if, guard문의 블록은 여러줄이 아닌 한줄로 구현.   
하나의 함수는 한가지의 일만 하도록 구현.   

```
//잘못된 코드
//guard문의 블록이 한줄을 넘어감
//또한 하나의 함수에서 다양한 일처리를 함
    func getVideo(videoKey:String) {
        webView.uiDelegate = self
        webView.navigationDelegate = self
        webView.configuration.allowsInlineMediaPlayback = true
        webView.allowsBackForwardNavigationGestures = true
        webView.allowsLinkPreview = true
        guard let url = URL(string: "https://www.youtube.com/embed/\(videoKey)") else {
            playerBackGroundView.isHidden = true
            webView.removeFromSuperview()
            return
        }
        self.webView.load(URLRequest(url: url))
    }

//좋은 코드
//guard문 블록안을 한줄로 유지함
//하나의 함수에서 하나의 일만 처리하는 중

    func setWebView() {
        webView.uiDelegate = self
        webView.navigationDelegate = self
        webView.configuration.allowsInlineMediaPlayback = true
        webView.allowsBackForwardNavigationGestures = true
        webView.allowsLinkPreview = true
    }
    
    func setVideo(videoKey:String) {
        guard let url = URL(string: "https://www.youtube.com/embed/\(videoKey)") else {
                handleFailedWebViewLoad()
            return
        }
        self.webView.load(URLRequest(url: url))
    }
    
    func handleFailedWebViewLoad() {
        playerBackGroundView.isHidden = true
        webView.removeFromSuperview()
    }
```

## 하나의 함수는 하나의 일만 해야한다는 원칙
하나의 함수에서 한가지 일만한다는 의미가 무엇이냐?    
함수의 이름 아래에서 추상화 수준이 하나라는 의미.   
위의 리팩토링된 코드에서 setVideo를 보면 분명 비디오를 로드시키고 실패했을때는 실패 처리도 한다.    
하지만 Video를 세팅한다는 이름 아래에 추상화 수준에서 볼때는 일을 하나만 하는 상태인것.     
    
함수 하나당 추상화 수준을 하나로 유지할것 이게 바로 한가지일만 한다는 의미이다.    
함수가 확실히 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야한다.    
추상화 수준이 섞이게되면 코드를 읽는 사람이 헷갈리게되고 코드가 추가될때마다 더러워짐.   
    
## Switch문
switch문에서 가장 주의 해야할점은     
애초에 스위치는 키워드가 많이 존재하므로 작게 만들기 힘들다 또한 N가지를 처리하기때문에 한가지만 작업하는 Switch문 또한 만들기가 힘듬.   
그렇기때문에 저차원 클래스에 숨겨 다형성을 이용.   
```
잘못된코드
func calculatePay(_ employee: Employee) -> Money throws InvalidEmplyeeType {
    switch employee {
        case .commissioned:
            return calculateCommissionedPay(employee)
        case .hourly:
            return calculateHourlyPay(employee)
        case .salaried:
            return calculateSalariedPay(employee)
        default:
            return InvalidImployeeType(employee.type)
    }
}
함수가 일단 길다. 또한 새 직원이 추가되면 계속해서 길어진다.  
한가지 작업만 수행하지 않는다    
아래 함수와 동일한 구조의 함수가 여러개 생길 가능성이 농후.   

좋은코드
protocol Employee {
    var isPayday: Bool { get }
    
    func calculatePay() -> Money
    func deliverPay(pay: Money)
}

protocol EmployeeFactory {
    func makeEmployee(employeeRecord: EmployeeRecord) throws -> Employee
}

class EmplyFactoryImpl: EmployeeFactory {
    func makeEmployee(employeeRecord: EmployeeRecord) throws -> Employee {
        switch employeeRecord {
            case .commissioned:
            return CommissionedEmployee(employeeRecord)
            case .hourly:
            return HourlyEmployee(employeeRecord)
            case .salaried:
            return SalariedEmployee(employeeRecord)
            default:
            throw InvalidImployeeTypeError(employee.type)
        }
    }
}

switch문을 똑같이 사용하지만 외부에서는 interface를 통해 접근하도록 추상화하여,    
사용하는쪽에서는 Switch에 존재를 모르게하여 외부에 따라 switch에 변경이 생기지 않도록 설계

```

